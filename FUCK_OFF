// /// TODO
// pub struct RspcTask<TCtx>(Inner<TCtx>);

// // impl<TCtx> From<RequestFuture> for RspcTask<TCtx> {
// //     fn from(value: RequestFuture) -> Self {
// //         Self(Inner::Future(value))
// //     }
// // }

// impl<TCtx: 'static> RspcTask<TCtx> {
//     // TODO: Break this out
//     pub(crate) fn new_stream(
//         router: Arc<BuiltRouter<TCtx>>,
//         ctx: TCtx,
//         input: Option<Value>,
//         req: RequestContext,
//     ) -> Result<Self, u32> {
//         let stream: *const _ = match router.subscriptions.store.get(req.path.as_ref()) {
//             Some(v) => v,
//             None => return Err(req.id),
//         };

//         let id = req.id;

//         // SAFETY: Trust me bro
//         let stream = unsafe { &*stream }
//             .exec
//             .dyn_call(ctx, input.unwrap_or(Value::Null), req);

//         Ok(Self(Inner::Stream {
//             _arc: router,
//             reference: stream,
//             id,
//         }))
//     }

//     pub fn id(&self) -> u32 {
//         match self.0 {
//             Inner::Stream { id, .. } => id,
//             Inner::Future(ref fut) => fut.id,
//             Inner::PendingDone { id } => id,
//             Inner::Done { id } => id,
//         }
//     }
// }

// // TODO: Concept of a task right now converts two things. A subscription and also in some senarios like the bad `Connection` abstraction a way to queue the futures onto the same executor hence enum.
// enum Inner<TCtx> {
//     Stream {
//         id: u32,
//         // We MUST hold the `Arc` so it doesn't get dropped while the stream exists from it.
//         _arc: Arc<BuiltRouter<TCtx>>,
//         // The stream to poll
//         reference: Pin<Box<dyn Body + Send>>,
//     },
//     #[deprecated]
//     Future(RequestFuture),
//     // When the underlying stream yields `None` we map it to a "complete" message and change to this state.
//     // This state will yield a `None` to tell the poller we are actually done.
//     PendingDone {
//         id: u32,
//     },
//     Done {
//         id: u32,
//     },
// }

// impl<TCtx: 'static> Stream for RspcTask<TCtx> {
//     type Item = exec::Response;

//     fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
//         match &mut self.0 {
//             Inner::Stream {
//                 id,
//                 ref mut reference,
//                 ..
//             } => {
//                 Poll::Ready(Some(match ready!(reference.as_mut().poll_next(cx)) {
//                     Some(r) => exec::Response {
//                         id: *id,
//                         inner: match r {
//                             Ok(v) => exec::ResponseInner::Value(v),
//                             Err(err) => exec::ResponseInner::Error(err.into()),
//                         },
//                     },
//                     None => {
//                         let id = *id;
//                         cx.waker().wake_by_ref(); // No wakers set so we set one
//                         self.set(Self(Inner::PendingDone { id }));
//                         exec::Response {
//                             id,
//                             inner: exec::ResponseInner::Complete,
//                         }
//                     }
//                 }))
//             }
//             Inner::Future(fut) => {
//                 let id = fut.id;
//                 // fut.poll(cx).map(|v| {
//                 //     cx.waker().wake_by_ref(); // No wakers set so we set one
//                 //     self.set(Self(Inner::PendingDone { id }));
//                 //     Some(v)
//                 // })
//                 todo!();
//             }
//             Inner::PendingDone { id } => {
//                 let id = *id;
//                 self.set(Self(Inner::Done { id }));
//                 Poll::Ready(None)
//             }
//             Inner::Done { .. } => {
//                 #[cfg(debug_assertions)]
//                 panic!("`StreamOrFut` polled after completion");

//                 #[cfg(not(debug_assertions))]
//                 Poll::Ready(None)
//             }
//         }
//     }

//     fn size_hint(&self) -> (usize, Option<usize>) {
//         match self.0 {
//             Inner::Stream { ref reference, .. } => reference.size_hint(),
//             Inner::Future { .. } => (0, Some(1)),
//             Inner::PendingDone { .. } => (0, Some(0)),
//             Inner::Done { .. } => (0, Some(0)),
//         }
//     }
// }

#![allow(unsafe_code)]
///! TODO: Explain this abstraction
// TODO: The goal is this can only know about the inner `T` and not `Arc<T>` but also ensure `ArcRef<T>` is not dropped until it's safe.
// TODO: This abstraction is safe because `&SomeDerivedType` is tied to the ownership of `Arc<T>` of which it was derived from.
// TODO: This is basically required for queueing an rspc subscription onto it's own task which with Tokio requires `'static`.
// TODO: This whole thing is really similar to the `owning_ref` crate but I want to erase the `T` from `Arc<T>` which is done through the `drop` function pointer.
use std::{
    mem::size_of,
    ops::{Deref, DerefMut},
    sync::Arc,
};

pub(crate) struct ArcRef<T: 'static> {
    // The lifetime here is invalid. This type is actually valid as long as the `Arc` in `self.mem` is ok.
    val: T, // &'static mut T,
    arc: *const (),
    drop: fn(*const ()),
}

unsafe impl<T: Send + 'static> Send for ArcRef<T> {}
unsafe impl<T: Sync + 'static> Sync for ArcRef<T> {}

impl<T: 'static> ArcRef<T> {
    // pub fn new<'a, A: 'static>(
    //     arc: Arc<A>,
    //     mut func: impl FnOnce(&'a Arc<A>) -> T + 'static,
    // ) -> Self
    // where
    //     T: 'a,
    pub unsafe fn new<A: 'static>(
        arc: Arc<A>,
        mut func: impl FnOnce(&'static Arc<A>) -> T + 'static,
    ) -> Self {
        debug_assert_eq!(
            size_of::<*const ()>(),
            size_of::<*const T>(),
            "pointer size mismatch"
        );

        // let val = (func)(&arc);

        // // SAFETY: We are forcing this value into a `'static` lifetime because it's lifetime is derived from the `Arc` which itself has a `'static` lifetime.
        // // SAFETY: For this to remain safe we hold the `arc` on self so the memory can't be deallocated while we are having the `'static` reference.
        // // SAFETY: We also ensure the `'static` never escapes the `ArcRef` by requiring `Deref` to use the inner value which itself ties the usage of the lifetime of `ArcRef`.
        // let val = unsafe { std::mem::transmute::<&mut T, &'static mut T>(&mut val) };

        let arc2 = arc.clone(); // TODO: Avoid clone?

        Self {
            val: (func)(&arc),
            arc: Arc::into_raw(arc2) as *const (),
            drop: |ptr| {
                // SAFETY: Reconstruct the arc from the pointer so Rust can decrement the strong count and potentially drop the memory if required.
                drop(unsafe { Arc::from_raw(ptr as *const A) });
            },
        }
    }
}

impl<T> Deref for ArcRef<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.val
    }
}

impl<T> DerefMut for ArcRef<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.val
    }
}

impl<T> Drop for ArcRef<T> {
    fn drop(&mut self) {
        (self.drop)(self.arc);
    }
}

// fn exec<TCtx: 'static>(
//     procedures: &ProcedureMap<TCtx>,
//     ctx: TCtx,
//     input: Option<Value>,
//     req: RequestContext,
// ) -> ExecutorResult<TCtx> {
//     // TODO: Increment the ref count and then decrement it on `ArcRef` being dropped but the `TCtx` type is properly erased.
//     // let y = crate::internal::exec::arc_ref::ArcRef {
//     //     drop: || {
//     //         drop(Result::<(), ProcedureStore<TCtx>>::Ok(())); // TODO: properly drop the inner content of the `Arc`
//     //     },
//     // };

//     // TODO: This is stupidly unsafe. If `RequestFuture` is held longer than `procedures` it's just a seg-fault. In practice that's unlikely to happen but it's still possible!
//     let procedures: *const _ = procedures;
//     let procedures = unsafe { &*procedures };

//     match procedures.get(req.path.as_ref()) {
//         Some(v) => ExecutorResult::Future(RequestFuture {
//             id: req.id,
//             stream: v.exec.dyn_call(ctx, input.unwrap_or(Value::Null), req),
//         }),
//         None => ExecutorResult::Response(Response {
//             id: req.id,
//             inner: ResponseInner::Error(ExecError::OperationNotFound.into()),
//         }),
//     }
// }
