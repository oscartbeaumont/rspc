// TODO: Probs unseal a heap of this
use std::{borrow::Cow, convert::Infallible};

use specta::{
    ts::TsExportError, DataType, DataTypeFrom, DefOpts, NamedDataType, StructType, TupleType, Type,
    TypeMap,
};

use crate::internal::{DynLayer, Layer};

/// @internal
#[derive(DataTypeFrom)]
#[cfg_attr(test, derive(specta::Type))]
pub(crate) struct ProceduresDef {
    #[specta(type = ProcedureDef)]
    queries: Vec<ProcedureDef>,
    #[specta(type = ProcedureDef)]
    mutations: Vec<ProcedureDef>,
    #[specta(type = ProcedureDef)]
    subscriptions: Vec<ProcedureDef>,
}

mod private {
    use super::*;

    impl ProceduresDef {
        pub fn new<'a, TCtx: 'a>(
            queries: impl Iterator<Item = &'a ProcedureTodo<TCtx>>,
            mutations: impl Iterator<Item = &'a ProcedureTodo<TCtx>>,
            subscriptions: impl Iterator<Item = &'a ProcedureTodo<TCtx>>,
        ) -> Self {
            ProceduresDef {
                queries: queries.map(|i| &i.ty).cloned().collect(),
                mutations: mutations.map(|i| &i.ty).cloned().collect(),
                subscriptions: subscriptions.map(|i| &i.ty).cloned().collect(),
            }
        }

        pub fn to_named(self) -> NamedDataType {
            let struct_type: StructType = self.into();
            struct_type.to_named("Procedures")
        }
    }

    /// Represents a Typescript procedure file which is generated by the Rust code.
    /// This is codegenerated Typescript file is how we can validate the types on the frontend match Rust.
    ///
    /// @internal
    #[derive(Debug, Clone, DataTypeFrom)]
    #[cfg_attr(test, derive(specta::Type))]
    pub struct ProcedureDef {
        pub key: Cow<'static, str>,
        #[specta(type = serde_json::Value)]
        pub input: DataType,
        #[specta(type = serde_json::Value)]
        pub result: DataType,
        #[specta(type = serde_json::Value)]
        pub error: DataType,
    }

    fn never() -> DataType {
        Infallible::inline(
            DefOpts {
                parent_inline: false,
                type_map: &mut Default::default(),
            },
            &[],
        )
        .unwrap()
    }

    impl ProcedureDef {
        pub fn from_tys<TArg, TResult, TError>(
            key: Cow<'static, str>,
            type_map: &mut TypeMap,
        ) -> Result<Self, TsExportError>
        where
            TArg: Type,
            TResult: Type,
            TError: Type,
        {
            Ok(ProcedureDef {
                key,
                input: match TArg::reference(
                    DefOpts {
                        parent_inline: false,
                        type_map,
                    },
                    &[],
                )? {
                    DataType::Tuple(TupleType::Named { fields, .. }) if fields.len() == 0 => {
                        never()
                    }
                    t => t,
                },
                result: TResult::reference(
                    DefOpts {
                        parent_inline: false,
                        type_map,
                    },
                    &[],
                )?,
                error: TError::reference(
                    DefOpts {
                        parent_inline: false,
                        type_map,
                    },
                    &[],
                )?,
            })
        }
    }

    // TODO: Rename this
    pub struct ProcedureTodo<TCtx> {
        pub(crate) exec: Box<dyn DynLayer<TCtx>>,
        pub(crate) ty: ProcedureDef,
    }

    impl<TCtx> ProcedureTodo<TCtx> {
        #[cfg(feature = "unstable")]
        pub fn ty(&self) -> &ProcedureDef {
            &self.ty
        }
    }
}

use crate::{BuildErrorCause, ProcedureMap};

pub(crate) fn is_valid_name(name: &str) -> Option<BuildErrorCause> {
    if name.is_empty() || name.len() > 255 {
        return Some(BuildErrorCause::InvalidName);
    }

    for c in name.chars() {
        if !(c.is_alphanumeric() || c == '_' || c == '-' || c == '~') {
            return Some(BuildErrorCause::InvalidCharInName(c));
        }
    }

    if name == "rspc" || name == "_batch" {
        return Some(BuildErrorCause::ReservedName(name.to_string()));
    }

    None
}

// TODO: Using track caller style thing for the panics in this function
pub(crate) fn append<TCtx: 'static, L: Layer<TCtx>>(
    (map, type_name): (&mut ProcedureMap<TCtx>, &'static str),
    key: String,
    exec: L,
    ty: ProcedureDef,
) {
    // TODO: Cleanup this logic and do better router merging
    #[allow(clippy::panic)]
    if key.is_empty() || key == "ws" || key.starts_with("rpc.") || key.starts_with("rspc.") {
        panic!("rspc error: attempted to create {type_name} operation named '{key}', however this name is not allowed.");
    }

    #[allow(clippy::panic)]
    if map.contains_key(&key) {
        panic!("rspc error: {type_name} operation already has resolver with name '{key}'");
    }

    map.insert(
        key,
        ProcedureTodo {
            exec: exec.erase(),
            ty,
        },
    );
}

pub(crate) use private::{ProcedureDef, ProcedureTodo};
