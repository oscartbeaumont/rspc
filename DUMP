// TODO: Private method
// pub(crate) fn id(&self) -> u32 {
//     self.id
// }

// pub(crate) fn exec<TCtx: 'static>(
//     ctx: TCtx,
//     procedures: *const ProcedureStore<TCtx>,
//     req: RequestContext,
//     input: Option<Value>,
// ) -> ExecutorResult<TCtx> {
//     // TODO: This unsafe is not coupled to the Arc which is bad
//     match unsafe { &*procedures }.store.get(req.path.as_ref()) {
//         Some(procedure) => ExecutorResult::FutureResponse(Self {
//             id: req.id,
//             stream: procedure
//                 .exec
//                 .dyn_call(ctx, input.unwrap_or(Value::Null), req),
//         }),
//         None => ExecutorResult::Response(Response {
//             id: req.id,
//             inner: ResponseInner::Error(ExecError::OperationNotFound.into()),
//         }),
//     }
// }

//     // TODO: Break this out
//     pub(crate) fn new_stream(
//         router: Arc<BuiltRouter<TCtx>>,
//         ctx: TCtx,
//         input: Option<Value>,
//         req: RequestContext,
//     ) -> Result<Self, u32> {
//         let stream: *const _ = match router.subscriptions.store.get(req.path.as_ref()) {
//             Some(v) => v,
//             None => return Err(req.id),
//         };

//         let id = req.id;

//         // SAFETY: Trust me bro
//         let stream = unsafe { &*stream }
//             .exec
//             .dyn_call(ctx, input.unwrap_or(Value::Null), req);

//         Ok(Self(Inner::Stream {
//             _arc: router,
//             reference: stream,
//             id,
//         }))
//     }
